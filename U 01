# Find All People With Secret :-

class UnionFind:
    def __init__(self):
        self.parent = {}

    def find(self, x):
        if x not in self.parent:
            self.parent[x] = x
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px != py:
            self.parent[py] = px
            
class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        meetings.sort(key=lambda x: x[2])

        secret = [False] * n
        secret[0] = secret[firstPerson] = True

        i = 0
        while i < len(meetings):
            time = meetings[i][2]
            uf = UnionFind()
            people = set()

            # Process all meetings at the same time
            while i < len(meetings) and meetings[i][2] == time:
                x, y, _ = meetings[i]
                uf.union(x, y)
                people.add(x)
                people.add(y)
                i += 1

            # Find components that already know the secret
            component_has_secret = set()
            for p in people:
                if secret[p]:
                    component_has_secret.add(uf.find(p))

            # Spread the secret within those components
            for p in people:
                if uf.find(p) in component_has_secret:
                    secret[p] = True

        return [i for i in range(n) if secret[i]]
